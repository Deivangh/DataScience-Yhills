from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!mv kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!unzip chest-xray-pneumonia.zip -d /content/

import torch
from torchvision import datasets, transforms
from torch.utils.data import DataLoader

# Image size for models like ResNet, VGG, EfficientNet
IMG_SIZE = 224

# Preprocessing for training (with augmentation)
train_transform = transforms.Compose([
    transforms.Resize((IMG_SIZE, IMG_SIZE)),
    transforms.Grayscale(num_output_channels=3),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(10),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

# Preprocessing for validation & test (no augmentation)
test_transform = transforms.Compose([
    transforms.Resize((IMG_SIZE, IMG_SIZE)),
    transforms.Grayscale(num_output_channels=3),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

# Used Colab path
data_dir = "/content/chest_xray"

train_data = datasets.ImageFolder(root=data_dir + "/train", transform=train_transform)
val_data   = datasets.ImageFolder(root=data_dir + "/val", transform=test_transform)
test_data  = datasets.ImageFolder(root=data_dir + "/test", transform=test_transform)

batch_size = 32
train_loader = DataLoader(train_data, batch_size=batch_size, shuffle=True)
val_loader   = DataLoader(val_data, batch_size=batch_size, shuffle=False)
test_loader  = DataLoader(test_data, batch_size=batch_size, shuffle=False)

# Check a batch
images, labels = next(iter(train_loader))
print(images.shape)   # Expected: [32, 3, 224, 224]
print(labels.shape)   # Expected: [32]



import  torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms, models
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt
import numpy as np
from google.colab import files
from PIL import Image
import os


# 1. Data Preprocessing

IMG_SIZE = 224

transform = transforms.Compose([
    transforms.Resize((IMG_SIZE, IMG_SIZE)),
    transforms.ToTensor(),
    transforms.Normalize([0.5], [0.5])   # normalize for grayscale
])

train_data = datasets.ImageFolder("/content/chest_xray/train", transform=transform)
val_data = datasets.ImageFolder("/content/chest_xray/val", transform=transform)
test_data = datasets.ImageFolder("/content/chest_xray/test", transform=transform)

train_loader = DataLoader(train_data, batch_size=32, shuffle=True)
val_loader = DataLoader(val_data, batch_size=32, shuffle=False)
test_loader = DataLoader(test_data, batch_size=32, shuffle=False)


# 2. Model (Transfer Learning with ResNet18)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = models.resnet18(pretrained=True)
model.fc = nn.Linear(model.fc.in_features, 2)  # 2 classes: Normal, Pneumonia
model = model.to(device)

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

MODEL_PATH = "pneumonia_model.pth"


# 3. Training (Only if model not saved)

if not os.path.exists(MODEL_PATH):
    print("Training model...")
    EPOCHS = 3
    for epoch in range(EPOCHS):
        model.train()
        running_loss = 0.0
        for images, labels in train_loader:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            running_loss += loss.item()
        print(f"Epoch [{epoch+1}/{EPOCHS}], Loss: {running_loss/len(train_loader):.4f}")

    # Save model
    torch.save(model.state_dict(), MODEL_PATH)
    print(f"Model saved at {MODEL_PATH}")
else:
    print("Loading saved model...")
    model.load_state_dict(torch.load(MODEL_PATH, map_location=device))


# 4. Evaluation

model.eval()
correct, total = 0, 0
with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = model(images)
        _, preds = torch.max(outputs, 1)
        correct += (preds == labels).sum().item()
        total += labels.size(0)

print(f"Test Accuracy: {100 * correct / total:.2f}%")


# 5. Prediction Function

def predict_image(model, image_path, device):
    model.eval()
    image = Image.open(image_path).convert("RGB")
    transform = transforms.Compose([
        transforms.Resize((IMG_SIZE, IMG_SIZE)),
        transforms.ToTensor(),
        transforms.Normalize([0.5], [0.5])
    ])
    image = transform(image).unsqueeze(0).to(device)

    with torch.no_grad():
        output = model(image)
        probs = torch.softmax(output, dim=1)
        _, pred = torch.max(output, 1)

    classes = ["Normal", "Pneumonia"]
    predicted_class = classes[pred.item()]
    confidence = probs[0][pred.item()].item() * 100
    print(f"Prediction: {predicted_class} (Confidence: {confidence:.2f}%)")

# 6. Upload Image & Predict

uploaded = files.upload()   # Upload image manually in Colab
for filename in uploaded.keys():
    predict_image(model, filename, device)
